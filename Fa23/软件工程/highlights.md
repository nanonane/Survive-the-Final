# 01 导言

**软件定义**：程序 + 数据 + 文档

**软件的特点**：

1. 软件是无形的、不可见的逻辑实体
   * 正确与否，一直到程序在机器上运行才能知道
   * 给设计、生产和管理带来许多困难
2. 软件是设计开发的，而不是生产制造的
3. 软件在使用过程中没有磨损、老化的问题
4.  软件是定制开发的

   * 虽然整个工业向着基于构件的构造模式发展，然而大多数软件仍是根据实际的顾客需求定制的
5. 软件的开发成本高
6.  软件易于复制

**分类**：

* 按功能：

  * 系统软件
  * 支撑软件
  * 应用软件

* 按规模：小型中型大型
  
* 按服务对象：项目软件，产品软件

**开发过程**：从问题空间 (所面临的特定问题域) 到解空间 (代码、文档) 的知识转换过程。
问题抽象 > 抽象问题理解 > 编写程序 > 部署运行

**典型软件项目**：分析，设计，编码，测试，维护

**诞生原因**：软件危机（进度难以预测，开发成本难以控制，⽤户对产品功能的要求难以满足，软件产品质量无法保证，软件产品难以维护）

**软件工程的定义**：以工程的原理、原则和方法进行软件开发

**关注点**：质量、成本、时间、功能。
相互冲突制约，需要权衡。

**内容层次**：工具（自动化完成软件工程）、方法（总结出一些模式）、过程（规范化）、质量关注点

# 02 软件过程

## 软件过程

**定义**：软件过程定义了软件组织和人员在软件产品的定义、开发和维护等阶段所实施的一系列活动（Activity）和任务（Task）。软件过程是一个为创建高质量软件所需完成的活动、动作和任务的框架。

**生存周期**

1. 定义阶段：问题定义，可行性研究和需求分析
2. 开发阶段：软件设计，程序编写，软件测试
3. 运维阶段：运行，维护

**开发模型**

对开发人员所采用的软件开发方法与过程组织整体结构的抽象描述。

经典开发模型：

1. **瀑布模型**：将软件开发的各个过程以线性的、顺序的方式进行

   主要问题：实际项目很少完全遵循。客户难以在一开始准确描述需求。可执行软件交付太晚。

2. **增量模型**：开发过程分成若干增量，每次只取最核心的需求，以迭代的方式使用瀑布模型

   客户反馈比瀑布模型更加及时，但缺少针对每次增量的时间和范围的指导建议

3. **演化模型**：通过周期性的迭代将各个阶段以螺旋扩增的方式进行编排。

   “原型”：客户与开发团队之间有效沟通的重要技术手段

4. **统一过程模型**：增量、迭代的过程流，每个迭代涉及核心过程工作流和核心支持工作流中的多个过程。在不同阶段，迭代工作流中的过程工作量是不同的。

## CMM与CMMI

软件供应商能力评估模型。

CMM: Capacity Maturity Model. 在此基础上集成相关模型逐步形成CMMI。

* 五个成熟度等级：初始级、已管理级、已定义级、量化管理级、优化级
* 22个过程域，每个成熟度等级中包含一组相关的过程域（表示需要具备相应的能力）
* 每个过程域内部定义了不同的能力等级（0-3）

## 敏捷开发

**开发原则**：适应变化，快速迭代；持续不断地、及早地交付有价值的软件；只做增量的短期计划并根据变化和反馈不断进行调整；业务人员和开发人员在整个过程中紧密合作；倡导可持续开发。

* 我们的最高优先级是持续不断地、及早地交付有价值的软件来使客户满意
* 拥抱变化，即使是在项目开发的后期，愿意为了客户的竞争优势而采取变化
* 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期
* 业务人员和开发人员在整个过程中紧密合作
* 围绕着被激励的个体构建项目，为个体提供所需的环境和支持，给予信任，从而达成目标
* 在团队内和团队间沟通信息的最有效和最高效的方式是面对面的交流
* 可工作的软件是衡量进度的首要标准
* 倡导可持续开发，项目发起者、开发人员和用户应该维持一个可持续的步调
* 持续地追求技术卓越和良好设计，可以提高敏捷性
* 以简洁为本，它是减少不必要工作的艺术
* 最好的体系结构、需求和设计是从自组织的团队中涌现出来的
* 团队定期地反思如何变得更加高效，并相应地调整自身的行为



**与精益思想的区别**

敏捷思想强调可持续的开发步调，定期反思如何变得更加高效；精益思想强调避免超负荷工作，重视系统和过程的持续改善。二者有相似的价值观，但敏捷思想的产出更有针对性，价值交付更密集，目标是通过小的迭代使开发过程更灵活。



**DevOps**：开发运维一体化

将敏捷的精神延伸到运维阶段，包含贯穿软件开发和运维的一系列实践集合。

Dev：

* 快速迭代的增量开发
* 持续的自动化测试
* 持续集成

Ops：

* 频繁部署
* 持续的质量和性能监控
* 快速的反馈和改进机制



**CI & CD**

* 持续集成，Continuous Integration，简称CI。开发人员频繁地将代码变更提交合并到中央存储库，并**自动运行构建和执行单元测试**，从而确保新代码可以和原有代码正确地集成在一起。使正在开发的软件始终处于可工作状态，更快地发现、定位和解决错误，提高软件质量，减少验证和发布新软件所需的时间。
* 持续交付，Continuous Delivery，简称CD。任何代码变更提交后都能够自动运行构建和执行单元测试，自动将所有代码变更**部署到测试环境和类生产环境**。让正在开发的软件始终处于可部署状态同时实现快速交付，能够应对业务需求，并更快地实现软件价值。
* 持续部署，Continuous Deployment，简称CD。任何代码变更提交后都能够自动运行构建和执行单元测试，自动将所有代码变更部署到测试环境、类生产环境以及**生产环境**。实现从代码变更提交到生产环境部署的全流程自动化而无需人工干预。加快代码提交到功能部署的速度，并能快速地收集真实用户的反馈。

![image-20231224160837053](highlights.assets\image-20231224160837053.png)

# 03 版本与开发任务管理

## 版本管理

版本管理的任务：

* 将各种软件制品都置于系统性的管理之中，进行版本标识
* 追踪演化历史
* 确保开发人员在并行协作开发过程中不会相互影响

**版本控制系统**

* 集中式版本控制系统：版本库集中存放在中央服务器上。

  缺点：必须联网才能工作，服务器单点故障影响整个团队，容易发生版本数据丢失

* 分布式版本控制系统：每个开发人员的客户端机器上都存储着完整的版本库

  优点：无需联网工作；版本库数据可以从任何本地库恢复，可靠性高；灵活、强大的分支管理

  ![image-20231224194328703](highlights.assets\image-20231224194328703.png)

**代码分支管理**：用于支持多个并行的互不干扰的分支，避免不同开发人员的提交混杂在一起，版本变得混乱，导致项目难以进行持续集成和发布。

## 开发任务管理

**变更管理**

客户需求变化，市场或技术因素发生变化等。需要一种规范、系统和可控的方式来管理软件变更流程，确保规范性和可追踪性。

流程：

1. 提交变更请求：来源，原因，内容；
2. 变更决策：由CCB（变更控制委员会）执行，讨论并评审变更的合理性、影响范围、实现工作量；
3. 变更的实施与追踪：发起特性开发任务，或事务性任务
4. 变更归档：记录变更从请求到实施与跟踪的整个流程，便于变更的问题追踪

**缺陷修复管理**

开发人员或测试人员在开发或测试过程中发现的缺陷、用户在使用过程中发现的缺陷。需要实现缺陷修复的有效管理和追踪，否则缺陷修复过程将变得混乱，例如缺陷的职责分配不清、缺陷修复的进度无法监控等。

1. 描述缺陷的现象、复现缺陷的步骤等
2. 评估缺陷的优先级和重要程度
3. 指派修复缺陷的负责人
4. 与相关开发人员讨论缺陷的修复方案
5. 跟踪缺陷的处理状态
6. 关联修复缺陷的代码提交

## 发布管理

**基于追踪的分析**：燃尽图

![image-20231224195839401](highlights.assets/image-20231224195839401.png)

- 横轴：显示工作天数
- 竖轴：显示剩余工作
- 计划剩余工作曲线：该曲线实际上是一条直线
- 实际剩余工作曲线：该曲线受团队实际工作效率的影响，在计划曲线上下浮动

**基于回溯的分析**

**SIPOC**：沿着流程找原因，清晰完整地展现出流程细节，用简洁直观的形式表现出流程的结构概况，为后续的分析奠定基础

* S：供应商（Supplier）
* I ：输入（Inputs）
* P：流程（Process）
* O：输出（Outputs）
* C：客户（Customer）

**鱼骨图**：针对一个问题（作为鱼头），由回溯小组经过充分讨论列明产生问题的大原因（鱼骨主干上的分支），从大原因继续反复论证，列举出每个大原因产生的中原因，中原因再论证小原因，如此一层层论证分析下去，直到找出所有可能的原因

**5why分析方法**：对一个问题连续问5个“为什么”以追究其根本原因。实际使用时，不限定只问5个“为什么”，主要是必须找到根本原因为止。



